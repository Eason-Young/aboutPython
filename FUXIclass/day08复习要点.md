复习要点：第八天 Flask框架的使用

---

#### 01-了解Flask框架

```
	Flask相对于Django而言是轻量级的Web框架。和Django不同，Flask轻巧、简洁，通过定制第三方扩展来实现具体功能。
	可定制性，通过扩展增加其功能，这是Flask最重要的特点。Flask的两个主要核心应用是Werkzeug和模板引擎Jinja2。
	Werkzeug是Python的WSGI规范的实用函数库，你可以通过它来创建你自己的框架或 Web 应用。
	直接使用的教程：https://werkzeug-docs-cn.readthedocs.io/zh_CN/latest/tutorial.html#id1
	Jinja2在目前WEB开发做前后端分离的大潮流下，使用会越来越少。

	Flask诞生于2010年，是Armin ronacher（人名）用Python语言基于Werkzeug工具箱编写的轻量级Web开发框架。它主要面向需求简单的小应用。
	Flask本身相当于一个内核，其他几乎所有的功能都要用到扩展（邮件扩展Flask-Mail，用户认证Flask-Login），都需要用第三方的扩展来实现。比如可以用Flask-extension加入ORM、窗体验证工具，文件上传、身份验证等。Flask没有默认使用的数据库，你可以选择MySQL，也可以用NoSQL。

Flask应该算是最灵活的框架之一，这也是Flask受到广大开发者喜爱的原因。

Flask常用的扩展包：
    Flask-SQLalchemy：操作数据库；
    Flask-migrate：管理迁移数据库；
    Flask-Mail:邮件；
    Flask-WTF：表单；
    Flask-script：插入脚本；
    Flask-Login：认证用户状态；
    Flask-RESTful：开发REST API的工具；
    Flask-Bootstrap：集成前端Twitter Bootstrap框架；
    Flask-Moment：本地化日期和时间；

```

---

#### 02-Flask框架的基本使用总结「重点」

```
1.根据flask模块中的Flask类即可创建一个初始状态的app对象，符合WSGI协议的application部分的规范；
2.通过app.router("/path", methods=["get","post",...])装饰一个函数，就创建了一个视图并设置了该视图的路由，视图函数可以不接受任何参数但必须有返回值。同一个视图函数，可以被装饰多次而拥有多个路由；
3.通过打印app.url_map可以查看已经注册的路由和对应的视图函数
4.框架自带了一个返回静态文件的视图，默认url是/static/<filename>
5.在URL中可以接受参数，写法：/user/<int:id>,那么这个地方表示接受参数id并且限定接受数字，视图函数要有相对应的形参。
6.视图函数可以返回多个值，其中包括状态码，返回值用逗号隔开。
7.abort(404)函数可以在视图的逻辑代码中主动抛出异常，终止该视图，接受的参数是响应状态码
8.flask中可以通过app.errorhandler(404)装饰器捕获异常，装饰器接受的参数是状态码。被装饰的函数接受异常信息，返回值再发送前端
9.通过flask模块的redirect函数，视图可以在控制网页的重定向
10.从总结5延生，我们可以通过创建继承于BaseConverter的类，自定义一个在路由中使用的参数过滤器。课件中创建了万能的正则转换器
11.视图代码逻辑中，可以通过创建的response对象的set_cookie方法给浏览器设置cookie。通过request对象的cookies属性获取从前端发送来的cookie信息
12.上下文：程序运行过程中的保存的一些信息；Flask中有请求上下文和应用上下文
13.请求上下文有：request对象，session对象；应用上下文：current_app对象和g对象。current_app的生命周期是整个服务器的生命周期，request对象和g对象的生命周期是一个http请求的生命周期。session对象保存的信息的生命周期由我们的代码控制；
14.请求钩子【Django中的中间件】可以帮我处理每一视图都要进行的预处理或者收尾的工作，通过装饰器实现，钩子不是装饰器。提供的钩子有：
	@app.before_first_request装饰出来的钩子:只在第一次的http请求之前执行
	@app.before_request装饰出来的钩子：在每一次http请求之前执行
	@app.after_request装饰出来的钩子：在每一次视图无异常完成之后执行，接受resp对象作为参数，并必须返回resp
	@app.teardown_request装饰出来的钩子：不管视图有无异常，在视图完成后执行；
15.可以通过第三方的flask-script模块，扩展命令行的使用
16.jinja2的模块语言相关内容，了解即可。现在的主流是前后端分离，后端不会在管数据在网页上如何渲染了。
17.flask通过render_template函数，可以渲染模版，并返回一个响应体对象，第一个参数是模版文件的名字。这个函数的返回值，就是渲染好数据之后的html字符串
18.通过flask模块的url_for(视图函数名，_external=True)可以生成这个视图函数的完整URL。
19.同一个视图可以设置允许多种请求方式，在执行逻辑代码时，我们可以通过request.method的值，判断走哪个分枝的代码；
20.从request.form可以获取到POST请求发送来的参数，form是一个类字典对象。
21.app的config属性可以看作字典，可以通过添加键值对的方式添置配置信息，键必须要大写才能识别；还有其他的导入配置的方式。不管何种方式导入的配置，都能通过app.config.get("KEY")或current_app.config.get("KEY")获取到对应的配置信息；
22.可以通过第三方模块flask-sqlalchemy管理数据库，实现ORM的功能。使用这个第三方模块需要在config对象中都添加一条以SQLALCHEMY_DATABASE_URI为键，以“数据库软件名称://用户名:密码@主机IP:服务端口/数据库名称”为值的配置。
23.通过flask-sqlalchemy模块的SQLAchemy类创建的db对象，我们可以实现根据模型类创建表和面向对象的CURD；
24.创建自定义的模型类：第一步，定义一个类继承于模型类的基类；第二步，根据要保存的数据抽象出字段名和数据类以及约束条件
25.数据库迁移，可以在表已经存在的情况下，修改表的结构；如果表不存在则创建新表。好处：避免每次更新模型类时都因为删除和重新创建对应的表而丢失数据。
26.可以使用第三方库Flask-Migrate作数据库迁移，并且集成到Flask-Script中，所有操作通过命令就能完成。命令和Django不一样！
27.在创建Flask对象或者Blueprint对象时，通过传入static_url_path参数可以设置标注访问静态文件的路由关键字，可以通过打印app.url_map查看。蓝图对象传入此参数只对该蓝图有用。
28.flask中的蓝图是指用于实现单个应用的视图、模板、静态文件的集合。不是单指通过Blueprint类创建的对象。蓝图可以帮助我们实现模块化应用的功能。蓝图可以有自己独立的静态文件夹和模版文件夹和静态文件标示路由。通过app.register_blueprint(blueprint_ob, url_prefix)注册蓝图，并添加区分蓝图的路由前缀。

```

---

#### 03-新经咨询项目学习总结

```
项目结构的总结：
	假如在入职之后接手一个旧的项目，第一件事，查看项目文件夹和文件的名字，大概猜测各个文件夹和文件的用处。
	不同文件存放资源用处不一样
	不同的文件的代码功能不一样
	把上线要用的其他服务的相关配置文件一起放在项目中
	⚠️：：开发后台管理功能，不一定必须得使用类似于Django的admin或xadmin模块。我们完全可以自己设计一套页面和一系列的功能「视图」。
	提供给用户使用的视图和提供给后台管理员使用的视图的最大不同在于对数据的操作权限。
	
项目第三方模块使用总结：
	flask-scritp   	创建manager对象来管理应用，使可以通过命令行接受参数执行功能
	flask-sqlachemy 做ORM映射，让我们可以通过面向对象的方式操作数据库
	flask-migrate	帮助做数据库迁移
	flask-wtf		为服务器开启CSRF防护功能
	flask-session	用来做session的状态保持功能
	captcha			生产图片验证码「公司一般都是直接使用第三方的验证平台服务，不会使用自己生成验证码图片」
	云通讯			  发送短信验证码
	七牛云			  存储静态文件
	
视图开发逻辑总结：
	第一步：分析需求，要返回的数据和要接收的参数；
		   主要看页面需要展示给用的数据和前后端交互的附加数据是哪些？
		   参数是为让我们后端检验这个请求，根据这个请求将数据操作的结果返回给对的“人”。
	
	第二步：创建视图函数或者方法「因为有一种视图叫类视图」，并注册路由。然后尝试请求这路由看能否调用这个视图。
	
	第三步：编写视图中的逻辑代码「根据需求去制定」：
			1，如果有参数，检查参数。并根据检查结果运行不同分支的代码
			2，具体的对数据的操作，获取操作的结果
			3，将结果返回给前端
	
	第四步：检查视图能否正常使用和对参数检验的健壮性
		   健壮性：尽量多的考虑到各种情况，并设计好应对方式。
```

---

#### 04-自己使用Flask框架搭建项目

	项目的简单理解：从代码层面来说，就是一系列文件的和文件夹的集合；
	
	项目文件的常见组成部分：
	
		程序主入口代码
	
		各个具体功能的代码模块
	
		配置文件和全局变量资源
	
		自定工具或第三发工具包
		
		log日志模块和日志文件

##### 课后作业「与第五点的课后作业二选一」创建一下的框架雏形并练习以下的功能，要求：

	创建一个简单的项目：
	
		结构：manager.py	程序入口，创建app的地方
	
			   config.py		存放各种配置类的文件
	
			   apps模块		保存程序各功能代码的文件夹
	
			   utils模块		存放自定义工具或第三方工具的文件夹
	
			   logs模块		设置日志配置和存放日志文件的地方
	
			   fontFiles文件夹	存放前端文件的文件夹，静态文件资源和模版
	
			   ownNginx.conf	存放本项目的Nginx配置的文件
	
			   ownuWSGI.ini	存放本项目的从uWSGI服务器启动的配置文件​	
	
	并让我们的项目能通过manager.py实现基本的运转
	
	其他功能：
	
		1.实现创建app对象时，使用工厂模式，能创建出分别用于开发、测试、生产三种环境的app对象
	
		2.使用蓝图将goods相关视图单独封装到一个模块中去
	
		3.使用pymysql创建自定义的数据库连接工具，并使用原生的SQL语句实现数据的curd
	
		4.使用sqlachemy第三方库实现数据的curd
	
		5.使用session和cookie记录用户的状态
	
		6.在后端作模版上的数据渲染
	
		7.使用ajax+vue在前端渲染数据
	
		8.添加自定义的log的handler对象，记录重要的操作，并按日志等级创建文件保存日志信息
	
		9.尝试使用中间件「钩子」，解决跨域请求问题

---

#### 05-通过官方文档重新学习使用Flask框架「课后作业—补充完成个人的学习总结」

	官方文档地址：http://docs.jinkan.org/docs/flask/

```
学习总结：
	1.通过Flask类创建的app对象就是符合WSGI协议application部分的规范的callable对象。
	2.直接运行【不通过Nginx或uWSGI时】Flask项目时，如果要成为外部可访问的服务器，只需要将IP地址绑定为0.0.0.0
	3.生产环境下一定不能开始交互式调试器，即不能在设置debug=True
	4.路由中可以使用正则表达式，并且可以设置转换器
	。。。。。。
	
```




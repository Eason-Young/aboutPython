

复习要点：第十天	DRF(DjangoRestFramework)框架的基本使用

原生Django视图配合序列化器的使用。

---

01-了解WEB应用模式和RESTful相关知识

```
WEB应用模式：
	1.前后端不分离：
		前端页面看到的效果都是由后端控制，由后端渲染页面或重定向，也就是后端需要控制前端的展示，前端与后端的耦合度很高。
		适合纯网页应用，但是当后端对接App时，App可能并不需要后端返回一个HTML网页，而仅仅是数据本身，所以后端原本返回网页的接口不再适用于前端App应用，为了对接App后端还需再开发一套接口。
	
	3.前后端分离：
		后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端自己决定，网页有网页的处理方式，App有App的处理方式，但无论哪种前端，所需的数据基本相同，后端仅需开发一套逻辑对外提供数据即可。
		前端与后端的耦合度相对较低。
		在前后端分离的应用模式中，我们通常将后端开发的每个视图都称为一个接口，或者API，前端通过访问接口来对数据进行增删改查。

RESTful：
	RESTful是一种开发理念。维基百科说：REST是设计风格而不是强行的标准。 REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）,一种万维网软件架构风格。
	遵循RESTful设计风格开发时要涉及到的内容：
		域名，版本，路径，HTTP请求方式动词，过滤信息，响应状态码，错误处理，返回结果，超媒体，数据格式
		
REST接口开发的核心任务：
    将请求的数据（如JSON格式）转换为模型类对象 「反序列化」
    通过模型类对象操作数据库
    将模型类对象转换为响应数据（如JSON格式）   「序列化」
   
序列化与反序列化的简单理解：
	序列化：将程序中的一个数据结构类型转换为其他格式（字典、JSON、XML等）
	反序列化：将其他格式（字典、JSON、XML等）转换为程序中的数据结构类型

在开发REST API接口时，我们在视图中需要做的最核心的事是：
    将数据库数据序列化为前端所需要的格式，并返回；
	将前端发送的数据反序列化为模型类对象，并保存到数据库中。
```

---

02-认识DRF「Django Rest Framework」框架

```
基本介绍：
	Django REST framework 框架是一个用于构建Web API 的强大而又灵活的工具。通常简称为DRF框架 或 REST framework。DRF框架是建立在Django框架基础之上，由Tom Christie大牛二次开发的开源项目。

功能：
	在序列化与反序列化时，虽然操作的数据不尽相同，但是执行的过程却是相似的，也就是说这部分代码是可以复用简化编写的。
    在开发REST API的视图中，虽然每个视图具体操作的数据不同，但增、删、改、查的实现流程基本套路化，所以这部分代码也是可以复用简化编写的：
    增：校验请求数据 -> 执行反序列化过程 -> 保存数据库 -> 将保存的对象序列化并返回
    删：判断要删除的数据是否存在 -> 执行数据库删除
    改：判断要修改的数据是否存在 -> 校验请求的数据 -> 执行反序列化过程 -> 保存数据库 -> 将保存的对象序列化并返回
    查：查询数据库 -> 将数据序列化并返回
Django REST framework的功能就是帮助我们简化上述两部分的代码编写，大大提高REST API的开发速度。

特点「优点」：
	提供了定义序列化器Serializer的基类，可以快速根据 Django ORM 或者其它库自动序列化/反序列化；
    提供了丰富的类视图、Mixin扩展类，简化视图的编写；
    丰富的定制层级：函数视图、类视图、视图集合到自动生成 API，满足各种需要；
    多种身份认证和权限认证方式的支持；
    内置了限流系统；
    直观的 API web 界面；
    可扩展性，插件丰富
 
缺点：
	封装过于完善，自己写的代码很少。一旦程序出现异常，排除异常比较困难。

安装与配置：
	DRF需要以下依赖：
    Python (2.7, 3.2, 3.3, 3.4, 3.5, 3.6)
    Django (1.10, 1.11, 2.0)
    DRF是以Django扩展应用的方式提供的，所以我们可以直接利用已有的Django环境而无需从新创建。（若没有Django环境，需要先创建环境安装Django）

官方文档：http://www.django-rest-framework.org/
官方教程：http://www.django-rest-framework.org/#tutorial
        1 - 序列化
        2 - 请求和响应
        3 - 基于类的视图
        4 - 身份验证和权限
        5 - 关系和超链接API
        6 - 视图集和路由器
        7 - 架构和客户端库
```

---

#### 03-DRF之序列化器的定义「重点」

```
1.定义方法：
	创建一个类，继承自rest_framework.serializers.Serializer。在这个类中定义一些类属性，这些类属性的定义方式类似于定义数据模型类，也是：字段名=字段类型（约束条件）。这里的数据类型与约束一般来说与模型类保持一致。「示例请看课件」
	⚠️：注意：serializer不是只能为数据库模型类定义，也可以为非数据库模型类的数据定义。serializer是独立于数据模型之外的存在。

2.字段「数据」类型「官方全部」：
	http://www.django-rest-framework.org/api-guide/fields/
	有哪些：布尔字段，字符串字段，数字字段，日期和时间字段，选择字段，文件上传字段，复合字段，其他字段，自定义字段。

3.通用约束条件「参数」：
    参数名称			说明
    read_only		表明该字段仅用于序列化输出，默认False
    write_only		表明该字段仅用于反序列化输入，默认False
    required		表明该字段在反序列化时必须输入，默认True
    default			反序列化时使用的默认值
    allow_null		表明该字段是否允许传入None，默认False
    validators		该字段使用的验证器
    error_messages	包含错误编号与错误信息的字典
    label			用于HTML展示API页面时，显示的字段名称
    help_text		用于HTML展示API页面时，显示的字段帮助提示信息
	还有一些字段类型使用的约束条件不是通用的，可以在课件中查看。

4.创建Serializer对象
	Serializer(instance=None, data=empty, **kwarg)
	说明：
	1）用于 序列化 时，instance参数接收一个 模型类对象 或者一个 查询集，如果是查询集，需要增加参数 many= True。如果是对单个对象进行序列化，不能传这个参数
	2）用于 反序列化 时，data参数接收Python的字典类型数据
	
```

---

#### 04-DRF之序列化与反序列化的使用「重点」

```
序列化功能的基本使用步骤：
	0.根据模型类和数据需求去闯将一个序列化器类
	1.查询出一个模型类的对象或查询集
	2.创建对应的序列化器对象，将模型类的对象或查询集作为初始化实参传给形参instance，当是查询集时需要额外附带一个参数：many=True。
	3.通过序列化器对象的 data 属性，即可获得获得序列化之后的数据。
	注：步骤就是这么简单，重点在于定义序列化器类时给字段设置的数据类型和约束条件。如果与模型类不匹配可能会出现问题。

关联对象的嵌套序列化：
「通俗说就是：对模型类中关系字段的数据进行序列化操作时怎么办，序列化器中怎么定义字段类型和约束条件」
    1）PrimaryKeyRelatedField 此字段将被序列化为关联对象的主键。
        指明字段时需要包含read_only=True或者queryset参数：
        包含read_only=True参数时，该字段将不能用作反序列化使用
        包含queryset参数时，将被用作反序列化时参数校验使用
	2) StringRelatedField 此字段将被序列化为关联对象的字符串表示方式（即__str__方法的返回值）
	3）SlugRelatedField 此字段将被序列化为关联对象的指定字段数据
		必须指明slug_field参数，指明使用关联对象的哪个字段
	5）直接使用关联对象的序列化器 获得一个orderdict对象，保存了关联对象的所有数据「这里的所有数据是指序列化器类中定义的字段的数据」
	6）自定义关联字段 通过重写to_representation方法，自定义获取关联对象的哪些数据。「重点」
		将该方法接收的参数 value 看成你的关联对象，然后自己根据需要返回你想要的值
```

```
反序列化功能的基本使用步骤：
	1.获取从前端发送来的数据，并将数据转换为Python的字典类型。
	2.创建对应的序列化器对象，将数据字典作为初始化实参传给形参data。如果是update操作，instance形参也要接实参，还如果是部分update的话，需要额外附带一个参数：partial=True
	3.调用序列化器的 is_valid()方法检验数据，此方法返回一个布尔值，当结果为True时才能继续执行代码。可以通过在这个方法中传入参数：raise_exception=True，当验证失败时会直接中止当前视图并向前端返回一个HTTP 400 Bad Request的响应。
	4.验证成功，可以通过序列化器对象的validated_data属性获取验证后的数据，拿去使用。

更多使用方法：
	1.如果在is_valid()方法调用时没有选择抛出异常，返回400响应。在这之后通过序列化器对象的 errors 属性获取到验证失败的具体原因。
	2.可以通过一些方式，补充更多的验证行为：
		1.通过定义 validate_<field_name> 方法，对某个字段做更多的验证
		2.通过定义validate方法，同时对多个字段进行更多的验证「推荐使用」
		3.定义序列化器类时，在字段中添加validators选项参数，该参数可以接受一个列表，也可以补充验证行为
	3.如果在验证成功后，想要基于validated_data完成数据对象的创建，可以通过在序列化器类中实现create()和update()两个方法来实现。之所以要用这两个方法名只不过是序列器基类中封装了一个 save()方法可以根据我们创建的序列化器对象自动选择是调用 create() 还是 update() 方法。如果是我们自己在视图中对验证后的数据做处理的话则随我们自己的代码，想怎么安排就怎么安排。
```

---

#### 05-模型类序列化器「重点」

````
如果我们想要使用序列化器对应的是Django的模型类，DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。
ModelSerializer与常规的Serializer相同，但提供了：
    基于模型类自动生成一系列字段
    基于模型类自动为Serializer的字段生成validators
    包含默认的create()和update()的实现

定义方法：
	1.继承自 rest_framework.serializers.ModelSerializer 类
	2.在序列化器类中再定义一个Meta类，Meta类继承于object基类

Meta类相关属性：
	model 				指明参照哪个模型类
	fields	 			来明确字段，__all__表名包含所有字段，也可以写明具体哪些字段，
	exclude				可以明确排除掉哪些字段
	depth				depth应该是整数，表明嵌套的层级数量，并且可以让我们看到关联对象的详细信息
	read_only_fields	指明只读字段，即仅用于序列化输出的字段
	extra_kwargs		为ModelSerializer添加或修改原有的选项参数

更多使用技巧：
	1.在处理关联字段的时，可以不指定depth属性，而是在序列化器类中添加一个字段指向关联字段的序列化器。参考 关联对象的嵌套序列化 第4条
	2.我们可以在模型类序列化器中定义更多 模型类字段 中没有的字段，使用时只需要记得在做数据对象保存操作时先将这些不属于模型类的字段数据从validated_data中删除即可
	3.对于自动生成和我们自己定义的同名字段，优先使用我们自己定义。
	4.关于序列化器对象调用save方法时，如果不是模型类序列化器，需要自己在序列化器类中重写create和update方法，如果是模型类序列化器，它已经帮我写好了。
````






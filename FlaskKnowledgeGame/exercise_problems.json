[
  {"question":"1.**Python2.x中与Python3.x中的默认编码区别？**",
   "answer":"Python2系列默认使用 Unicode 编码，不支持中文。<br>Python3系列默认使用 UTF-8 编码，支持中文"},
  {"question":"2.**Python中的变量实质是什么？**",
   "answer":"Python中的变量的实质是引用，保存了数据的内存地址" },
  {"question":"3.**面向对象编程三要素是哪些，你如何理解？**",
   "answer":"面向对象三要素：封装、继承和多态<br>封装：就是将可以复用的代码块用函数或类封装起来，在需要使用的地方直接调用，而不需要重复编写。<br>继承：在Python中子类可以继承父类的方法和属性，不要求重新定义。<br>多态：Python天生支持多态，根据据不同的初始化参数，同一个类创建出来的不同对像调用同名的属性或方法的结果可以不一样." },
  {"question":"4**Python中子类如何在自己定义的方法中调用父类的方法，以及在Python2/3两个系列的版本中使用上有什么不同？**",
   "answer":"Python中子类在自己定义的方法中可以通过内置对象 super() 调用父类的方法.<br>在Python2系列版本中使用 super() 需要传递两个参数, 一个是当前类的名称,一个是表示对象本身的 self<br>在Python3系列版本中使用 super() 可以不传参数" },
  {"question":"5**什么叫做单例模式,以及在Python使用类与对象时如何实现单例模式?**",
   "answer":"单例模式:是代码运行的过程使用某个对象时,始终保证该对象是其初始创建时得到的第一个对象,而不是后来新创建的对象.<br>在Python中使用类与对象时实现单例模式思路:<br>核心:重写 __new__ 魔法方法<br>逻辑:在 __new__ 魔法方法中调用 super() 使用 Object 基类的 __init__ 魔法方法创建对象时,先判断该类是否已经创建了一个实例对象;如果没有创建过,则创建新的实例对象,并保存到一个类属性中记录下来;如果已经创建,则直接返回相应类属性中保存的已经创建好的实例对象" },
  {"question":"6.**Python2系列版本中的内置对象 range() 和 xrange() 有什么不同?**",
   "answer":"range() 是函数,直接返回一个列表<br>xrange() 是一个生成器,每次返回一个数据a" },
  {"question":"7.**现在有 Variable01= 1, Variable02 = 10 如何不使用的中间变量交换这个两个变量的值,并说明其中的原理?**",
   "answer":"Variabel01, Variable02 = Variable02, Variable01<br>原理:等号后面的其实是一个元组,整个表达式是在对元组拆包赋值给等号前的两个变量" },
  {"question":"8.**在文件读取操作中read、readline 和 readlines 的区别?**",
   "answer":"read:读取整个文件。<br>readline:读取下一行，使用生成器方法。<br>readlines:读取整个文件到一个迭代器以供我们遍历。" },
  {"question":"9.**赋值、浅拷贝、深拷贝的区别?**",
   "answer":"在Python中，对象的赋值就是简单的对象引用.对同一个对象,无论赋值几次给几个不同的变量,这些变量保存的内存地址都一样.<br>浅拷贝会创建新对象，其内容非原对象本身的引用，而是原对象内第一层对象的引用。<br>深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空间开销要高。" },
  {"question":"10.**魔法方法`__init__`方法和`__new__`方法的区别? **",
   "answer":"__init__ 在对象创建后，对对象进行初始化。<br>__new__ 是在对象创建之前创建一个对象，并将该对象返回给 __init__。" },
  {"question":"11.**什么是操作系统？操作系统有什么作用?**",
   "answer":"操作系统（Operation System，OS）是管理硬件和控制软件运行的计算机程序, 是直接运行在“裸机”上的系统软件, 任何其他软件都必须在操作系统的支持下才能运行.<br><br>主要作用是向下控制硬件向上支持软件的运行，具有承上启下的作用，所有的软件都直接依赖于操作系统的支持" },
  {"question":"12.**Linux 中的命令由几部分组成？分别说出每部分的功能。**",
   "answer":"命令格式：command [-options] [parameter]<br>分别由 命令 选项 参数 三部分组成<br><br>command-命令，命令表示要做什么<br>options-选项，选项表示怎么做,一般指定命令的附加功能（可以省略）<br>parameter-参数，参数表示对谁做. 是命令作用的目标，可以是任意个（可以省略）" },
  {"question":"13.**什么是socket？在进行socket连接时，有哪些方式？** ",
   "answer":"socket(简称 套接字) 是进程间通信一个工具，它能实现把数据从一方传输到另外一方，完成不同电脑上进程之间的通信， 它好比数据的搬运工。<br><br>在建立socket连接时，有TCP和UDP两种连接方式。" },
  {"question":"14.**请简述TCP与UDP之间的区别「至少4点」。**",
   "answer":"1.TCP 面向连接; UDP 是不面向连接;<br>2.TCP 提供可靠的数据传输，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP 不保证可靠的数据传输，容易出现丢包情况;<br>3.TCP 需要连接传输速度慢，UDP 不需要连接传输速度快<br>4.TCP 不支持发广播; UDP 支持发广播<br>5.TCP 对系统资源要求较多，UDP 对系统资源要求较少。<br>6.TCP 适合发送大量数据，UDP 适合发送少量数据<br>7.TCP 有流量控制，UDP 没有流量控制" },
  {"question":"15.**简述TCP在建立连接时的三次握手的过程。**",
   "answer":"第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。<br>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。<br>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。"},
  {"question":"16.**简述TCP在断开连接时四次挥手的过程。**",
   "answer":"第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送。<br>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1。<br>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送。<br>第四次挥手：Client收到FIN后，接着发送一个ACK给Server，确认序号为收到序号+1。"},
  {"question":"17.**什么是多任务编程？多任务编程有哪些实现方式？**",
   "answer":"多任务是指在同一时间内，同时去做多个事情。<br>在多任务编程时，可以使用进程，线程和协程的方式来实现多任务编程。"},
  {"question":"18.**线程在执行时有什么特点？**",
   "answer":"线程是程序执行的最小执行单位，由CPU进行调度执行<br>线程在执行时是无序的，不能对线程的执行顺序进行控制 "},
  {"question":"19.**如何解决在线程共享数据时出现的资源竞争问题？**",
   "answer":"1.可以通过在程序中加入互斥锁来解决共享变量的资源竞争问题。互斥锁为资源引入一个状态：锁定/非锁定.<br>2.使用队列保存共享数据,当一个线程从队列中获取到一个共享数据后,其他线程将获取不到进入阻塞等待状态.当前线成使用完该共享资源后再将其放回队列给其他线程使用."},
  {"question":"20.**进程在执行过程中的状态有几种？**",
   "answer":"就绪态：运行的条件都已经满足，正在等在cpu执行<br>执行态：cpu正在执行其功能<br>等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态"},
  {"question":"21.**什么是协程？python中如何实现协程？常用的协议模块有哪些？**",
   "answer":"协程，又称微线程，纤程,也称为用户级线程，在不开辟线程的基础上完成多任务，也就是在单线程的情况下完成多任务，多个任务按照一定顺序交替执行.<br>通俗理解只要在def里面只看到一个yield关键字表示就是协程<br>Python 可以使用 greenlet 和gevent 模块来实现协程"},
  {"question":"22.**简述线程，进程和多协程之间的区别「至少4点」。**",
   "answer":"进程、线程、协程都是可以完成多任务编程。<br>1.进程之间不共享全局变量<br>2.线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步<br>3.创建进程的资源开销要比创建线程的资源开销要大<br>4.进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位<br>5.线程不能够独立执行，必须依存在进程中<br>6.多进程开发比单进程多线程开发稳定性要强<br>7.协程切换任务资源很小，效率高"},
  {"question":"23.**什么是正则表达式？正则表达式的作用是什么？**",
   "answer":"正则表达式是用来记录文本规则的特殊字符串<br><br>正则表达式用来在程序开发过程中匹配或者查找符合某些规则的字符串。比如:邮箱、图片地址、手机号码等"},
  {"question":"24.**在正则表达式中，什么是贪婪匹配？什么是非贪婪匹配？如何实现非贪婪匹配？**",
   "answer":"贪婪匹配是指在进行规则匹配时，总是尝试匹配尽可能多的字符，python中默认贪婪匹配<br>非贪婪匹配是指在进行规则匹配时，总是尝试匹配尽可能少的字符。<br>非贪婪操作符 '?' ，可以这个操作符可以用在'*','+','?'的后面,实现非贪婪匹配"},
  {"question":"25.**请简述浏览器访问HTTP服务器的过程。**",
   "answer":"1.用户输入网址.<br>2.浏览器请求DNS服务器, 获取域名对应的IP地址.<br>3.请求连接该IP地址服务器.<br>4.发送资源请求. (HTTP协议)<br>5.web服务器接收到请求, 并解析请求, 判断用户意图.<br>6.获取用户想要的资源.<br>7.将资源返回给web服务器程序.<br>8.web服务器程序将资源数据通过网络发送给浏览器.<br>9.浏览器解析请求的数据并且完成网页数据的显示."},
  {"question":"26.**简述TCP长/短连接的优点和缺点。**",
   "answer":"长连接可以省去较多的TCP建立和关闭的操作，节约时间。但是如果用户量太大容易造成服务器负载过高最终导致服务不可用<br>短连接对于服务器来说实现起来较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但是如果用户访问量很大, 往往可能在很短时间内需要创建大量的连接，造成服务器响应速度过慢"},
  {"question":"27.**符合HTTP协议的数据报文的基本结构?**",
   "answer":"行信息+头信息+空行+体信息"},
  {"question":"28.**HTTP状态码有哪几类？分别表示什么功能？**",
   "answer":"1XX系列：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。<br>2XX系列：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201。<br>3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。这系列中最常见的有301、302状态码。<br>4XX系列：表示请求错误。代表了客户端发送的数据看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。<br>5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。"},
  {"question":"29.**列举常见关系型数据库,及应用场景。「至少三个」**",
   "answer":"oracle 银行,电信等高安全性要求项目<br>ms sql server：在微软的项目中使用<br>sqlite：轻量级数据库，主要应用在移动平台<br>mysql：web时代使用最广泛的关系型数据库"},
  {"question":"30.**结构化查询语言SQL中，定义的DML，DQL分别包括哪些操作？**",
   "answer":"DML： 数据操作语言，包括 insert插入，update 更新，delete删除操作<br>DQL： 数据查询语言，包括 select 查询操作"},
  {"question":"31.**简述使用pymysql模块对数据库编程时，需要经过哪几步？每一步的作用是什么？**",
   "answer":"使用pymysql模块进行数据库编程时，需要经过五步。<br>1.建立数据库连接对象<br>2.获取游标对象<br>3.执行SQL语句<br>4.关闭游标对象<br>5.关闭数据库连接对象"},
  {"question":"32.**简述MySQL数据库中视图的作用和特点。**",
   "answer":"视图只是一个虚表，封装了对多张基本表进行复杂操作的SQL语句，可以简化用户操作。<br>视图并不存储任何基本表的表数据,当用户使用视图的时候 视图会从基本表中取出<br>通过视图可以对用户展示指定字段从而屏蔽其他字段数据，更加安全"},
  {"question":"33.**简述事务的作用，事务的四大特性都是什么？**",
   "answer":"事务Transaction，是指作为一个基本工作单元执行的一系列SQL语句的操作，要么全部都执行，要么全都不执行，来保证一个工作单元的完整执行。<br>事务有ACID四大特性：<br>1. 原子性(Atomicity)<br>2. 一致性(Consistency)<br>3. 隔离性(Isolation)<br>4. 持久性(Durability)"},
  {"question":"34.**什么是GIL？对程序有什么影响？如何解决GIL对程序的影响答？**",
   "answer":"GIL ( Global Interpreter Lock ) 全局解释器锁。<br>GIL 不是 Python 语言的语法，是CPython解释器中的一个特性，GIL只在CPython解释器中存在，是Python 解释层面的锁，用来解决解释器中多个线程的竞争资源问题。由于 GIL 的存在， Python程序中同一时刻有且只有一个线程会执行，Python 中的多线程无法利用多核 CPU，Python 中的多线程不适合计算密集型的程序运行。<br>如果要解决GIL对程序带来的影响，可以通过更换解释器，升级解释器版本，或使用多进程来替换多线程进行编程等方式来解决GIL对程序的影响。但是这些方式并不能完全解决问题。"},
  {"question":"35.**简述 什么是MRO，在多继承时起到什么作用？**",
   "answer":"MRO：Method Resolution Order，即方法解析顺序.<br>MRO是python中的一个魔法属性，用来保存类在实现多继承时的解析顺序保证类在实例对象进行初始化操作时，继承的父类都可以正确执行，不会出现重复执行的问题。"},
  {"question":"36.**在实现上下文管理器时，需要实现哪两个方法？分别起到什么作用？**",
   "answer":"上下文管理器本质就是能够支持with操作。<br>任何实现了 __enter__() 和 __exit__() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。<br>__enter__()方法主要实现初始化操作<br>__exit__() 方法主要实现善后处理工作，比如资源的关闭释放等"},
  {"question":"37.**简述定义闭包函数的必须要满足的条件**",
   "answer":"在使用闭包实现装饰器时，闭包函数的定义要满足三个条件：<br>1.在外函数内部定义一个内函数。<br>2.内函数中使用了外函数中定义的变量。<br>3.外函数返回内函数的引用。"},
  {"question":"38.**简述 静态数据 和 动态数据 的区别,可以举例说明?。**",
   "answer":"静态数据是指设计者把页面上所有东西都设定好、做死了，然后放上去，不管是谁在任何时候看到的页面内容都是一样的，一成不变（除非手动修改页面内容）。例如:html页面文件，CSS样式文件, JS脚本文件等<br>动态数据的内容一般都是依靠服务器端的程序来生成的，不同人、不同时候访问页面，显示的内容都可能不同。例如我们在WEB后端视图中从数据库中查询出来的用户信息,或商品信息等."},
  {"question":"39.**在前端页面中,影响盒子模型的样式属性有哪些?**",
   "answer":"1.元素自己本身的宽高<br>2.边框boder<br>3.内边距padding<br>4.外边距margin"},
  {"question":"40.**事件委托或事件代理的优点及语法?**",
   "answer":"优点：减小事件绑定次数，提高代码执行效率；可以给未来添加的元素绑定事件<br>语法：delegate(发生事件的元素, 事件属性, 匿名函数)"},
  {"question":"41.**什么叫做 局部刷新 ?  如何实现 局部刷新 ?**",
   "answer":"局部刷新：在不刷新整个页面的情况下，重新加载页面上的部分内容，也叫做零刷新。<br>实现：通过ajax或axios向后端发送网络请求数据，将获取到的响应对象中的数据使用Vue或其他的前端模版引擎将数据渲染到页面上。也可以通过自己写JS代码，将数据处理成完整的标签字符串之后添加或者替换到页面中去。"},
  {"question":"42.**描述web服务器和web框架的作用及其关系。**",
   "answer":"web服务器作用：<br>1）解析请求报文,调用框架程序处理请求。 <br>2）组织响应报文,返回内容给客户端。<br>web框架程序的作用：<br>1）路由分发(根据url找到对应的处理函数) 。<br>2）在处理函数中进行业务的处理。 "},
  {"question":"43.**请说明Flask框架中的钩子函数的作用及其调用顺序。**",
   "answer":"在web服务器调用框架程序处理每个请求的过程中，框架的处理有一定的顺序，在某个处理的节点上，允许我们根据实际的需要添加相应的函数，这些函数叫做钩子函数。有了钩子函数，我们可以根据自己的需要在请求前后添加函数进行一些处理。<br>before_first_request 在服务器启动之后，接收第一个请求时调用<br>before_request 处理每个请求时，在视图函数调用之前调用<br>after_reuqest 处理每个请求时，在视图函数调用之后并且视图未抛出异常时调用<br>teardown_request 处理每个请求时，在视图函数调用之后调用，如果视图抛出异常，此函数的参数就是抛出的异常对象"},
  {"question":"44.请说明为什么需要进行状态保持及状态保持的方案和特点。",
   "answer":"http协议是一个无状态协议，即同一个用户进行操作时，服务器在处理某个请求时并不知道上一次请求的操作，但在开发过程中，实际需要去保存一些操作的信息以备之后进行使用，所以需要进行状态保持。<br>cookie特点：<br>1）由服务器生成，交给浏览器进行保存的一小段文本信息。2）cookie以键和值的形式进行存储。3）浏览器在访问服务器时，会自动将和被访问服务器相关的所有cookie信息发送给对应的服务器。4）cookie存在过期时间，默认关闭浏览器过期。<br>session特点：<br>1）session保存在服务器端。2）session以键和值的形式进行存储。3）session依赖于cookie，每个客户端对应的session信息的标识保存在cookie中。4）session也是由过期时间的，Flask框架中session默认关闭浏览器过期。"},
  {"question":"45.**描述一下对`CSRF(跨站请求伪造)`的理解。**",
   "answer":"1. 用户C登录正常网站A，网站A校验登录成功之后，在session中记住了用户C的登录状态。<br>2. 网站A返回应答给用户C时，让用户C的浏览器保存一个cookie信息，比如名为sessionid(用户C浏览器对应的session信息的标识)。<br>3. 用户C在没有退出网站A的情况下，使用浏览器访问了另外一个网站B。<br>4. 网站B返回给用户C的浏览器一个页面，在这个页面上有链接地址D是指向网站A的地址(此链接可能进行了伪装，吸引用户C点击)。<br>5. 用户C如果点击这个链接D，则用户C的浏览器会向网站A发起请求，同时会将sessionid发送给网站A。<br>6. 网站A认为是用户C之前登录的用户要执行操作，就会以用户C的身份做一些事情(比如转账和修改密码)。"},
  {"question":"46.**`ORM`是什么?主要做什么事情?有什么优缺点?**",
   "answer":"ORM中文意为 对象-关系映射.<br>主要功能:主要实现模型对象到关系数据库数据的映射.<br>优点:<br>只需要面向对象编程, 不需要面向数据库编写代码.<br>对数据库的操作都转化成对类属性和方法的操作.<br>不用编写各种数据库的sql语句.<br>实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异.<br>不在关注用的是mysql、oracle...等.<br>通过简单的配置就可以轻松更换数据库, 而不需要修改代码.<br>缺点: <br>相比较直接使用SQL语句操作数据库,有性能损失.<br>根据对象的操作转换成SQL语句,根据查询的结果转化成对象, 在映射过程中有性能损失."},
  {"question":"47.**Flask框架中蓝图的作用是什么?**",
   "answer":"Flask使用Blueprint让应用实现模块化<br>方便我们将不同的功能模块单独封装起来使用,让项目的代码结构更加优秀,不同功能间的耦合性更低.让我们在实际工作中可以每个人分工合作,开发自己负责的功能模块"},
  {"question":"48.**在开发过程中为什么要使用虚拟环境?**",
   "answer":"虚拟环境可以搭建独立的python运行环境, 使得单个项目的运行环境与其它项目互不影响.方便我们同时开发多个项目,并且在项目部署时,我们可以清楚的知道当前项目所必需的模块;那么在部署时就只需要将该项目所必需的模块配置好即可."}
]